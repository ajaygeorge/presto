# SELECT with no table.

query I
SELECT 1
----
1

query T
SELECT NULL
----
NULL

query II colnames
SELECT 1+1 AS two, 2+2 AS four
----
2   4

# SELECT expression tests.

statement ok
CREATE TABLE abc (a INT, b INT, c INT)

statement error mismatched input 'FROM'
SELECT FROM abc

statement error WHERE clause must evaluate to a boolean
SELECT * FROM abc WHERE 'hello'

statement ok
INSERT INTO abc VALUES (1, 2, 3)

query III colnames
SELECT * FROM abc
----
1 2 3

query TIII colnames
SELECT NULL AS z, * FROM abc
----
NULL 1  2  3

query III colnames
SELECT * FROM abc WHERE NULL
----

query III colnames
SELECT * FROM abc WHERE a = NULL
----

query IIIIII colnames
SELECT *,* FROM abc
----
1 2 3 1 2 3

query IIII colnames
SELECT a,a,a,a FROM abc
----
1 1 1 1

query II colnames
SELECT a,c FROM abc
----
1 3

query I colnames
SELECT a+b+c AS foo FROM abc
----
6

# Contradiction
query III
SELECT * FROM abc WHERE a > 5 AND a < 5
----

# Contradiction with remainder filter
query III
SELECT * FROM abc WHERE a > 5 AND a < 5 AND b>=100
----

statement ok
INSERT INTO abc VALUES (0, 1, 2)

query II
SELECT a,b FROM abc WHERE CASE WHEN a != 0 THEN b/a > 1.5 ELSE false END
----
1 2

# SELECT of NULL value.

statement ok
CREATE TABLE kv (k CHAR, v CHAR)

statement ok
INSERT INTO kv (k) VALUES ('a')

query TT
SELECT * FROM kv
----
a NULL

query TT
SELECT k,v FROM kv
----
a NULL

query T
SELECT v||'foo' FROM kv
----
NULL

query T
SELECT lower(v) FROM kv
----
NULL

query T
SELECT k FROM kv
----
1 value hashing to 60b725f10c9c85c70d97880dfe8191b3

query TT
SELECT kv.K,KV.v FROM kv
----
a NULL

query TT
SELECT kv.* FROM kv
----
a NULL

statement error SELECT * not allowed in queries without FROM clause
SELECT *

query T colnames
SELECT FOO.k FROM kv AS foo WHERE foo.k = 'a'
----
a

query T
SELECT "foo"."v" FROM kv AS foo WHERE foo.k = 'a'
----
NULL

statement ok
CREATE TABLE kw ("from" INT)

statement ok
INSERT INTO kw VALUES (1)

query III colnames
SELECT *, "from", kw."from" FROM kw
----
1    1    1

statement ok
CREATE TABLE xyzw (x INT, y INT, z INT, w INT)

statement ok
INSERT INTO xyzw VALUES (4, 5, 6, 7), (1, 2, 3, 4)

statement error mismatched input
SELECT * FROM xyzw LIMIT x

statement error argument of LIMIT must be type int, not type decimal
SELECT * FROM xyzw LIMIT 3.3

query IIII
SELECT * FROM xyzw ORDER BY 1 LIMIT '1'
----
1 2 3 4

#negative value for LIMIT is a better message
statement error mismatched input '-'
SELECT * FROM xyzw LIMIT -100

statement error numeric constant out of int64 range
SELECT * FROM xyzw LIMIT 9223372036854775808

query IIII
SELECT * FROM xyzw ORDER BY x OFFSET 1 + 0.0
----
4 5 6 7

query T rowsort
SELECT (x,y) FROM xyzw
----
(1,2)
(4,5)

query IIII
SELECT * FROM xyzw LIMIT 0
----

query IIII
SELECT * FROM xyzw ORDER BY x LIMIT 1
----
1 2 3 4

statement error pgcode 42601 multiple LIMIT clauses not allowed
((SELECT a FROM t LIMIT 1)) LIMIT 1

query II rowsort
SELECT z, y FROM xyzw@foo
----
3 2
6 5

query I
SELECT z FROM test.xyzw@foo WHERE y = 5
----
6

query I
SELECT xyzw.y FROM test.xyzw@foo WHERE z = 3
----
2

statement error pgcode 42P01 relation "test.unknown" does not exist
SELECT z FROM test.unknown@foo WHERE y = 5

statement error index "unknown" not found
SELECT z FROM test.xyzw@unknown WHERE y = 5

query I
SELECT w FROM test.xyzw@foo WHERE y = 5
----
7

statement ok
CREATE TABLE boolean_table (
  id INTEGER NOT NULL,
  value BOOLEAN
)

statement ok
INSERT INTO boolean_table (id, value) VALUES (1, NULL)

query I
SELECT value FROM boolean_table
----
NULL

query I
SELECT CASE WHEN NULL THEN 1 ELSE 2 END
----
2

statement ok
INSERT INTO abc VALUES (42, NULL, NULL)

query III rowsort
SELECT 0 * b, b % 1, 0 % b from abc
----
0 0 0
0 0 0
NULL NULL NULL

# Doing an index lookup by MaxInt used to not work.
# https://github.com/cockroachdb/cockroach/issues/3587
statement ok
CREATE TABLE MaxIntTest (a INT)

statement ok
INSERT INTO MaxIntTest VALUES (9223372036854775807)

query I
SELECT a FROM MaxIntTest WHERE a = 9223372036854775807
----
9223372036854775807

statement error no value provided for placeholder
SELECT $1::int

# Regression tests for #22670.
query B
SELECT 1 IN (1, 2)
----
true

query B
SELECT NULL IN (1, 2)
----
NULL

query B
SELECT 1 IN (1, NULL)
----
true

query B
SELECT 1 IN (NULL, 2)
----
NULL

# Note: The desired behavior here differs from the desired behavior of
# NULL IN <subquery> as tested below.
query B
SELECT NULL IN ((1, 1))
----
NULL

query B
SELECT (1, NULL) IN ((1, 1))
----
NULL

query B
SELECT (2, NULL) IN ((1, 1))
----
false

statement error unsupported comparison operator: .* expected 1 to be of type tuple, found type int
SELECT () IN (1,2)

statement error unsupported comparison operator: .* expected tuple \(1, 2\) to have a length of 0
SELECT () IN ((1,2))

query B
SELECT () IN (());
----
true

statement error unsupported comparison operator: .* could not parse "string" as type int
SELECT ('string', NULL) IN ((1, 1))

statement error unsupported comparison operator: .* expected tuple \(1, 1\) to have a length of 3
SELECT (2, 'string', NULL) IN ((1, 1))

query B
SELECT (1, 1) IN ((1, NULL))
----
NULL

query B
SELECT (1, 1) IN ((2, NULL))
----
false

# Tests with a tuple coming from a subquery.
query B
SELECT NULL IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

query B
SELECT (1, NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

statement error unsupported comparison operator: <unknown> IN <tuple{tuple{int AS a, int AS b}}>
SELECT NULL IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b));

statement error unsupported comparison operator: <tuple> IN <tuple{int}>
SELECT () IN (SELECT * FROM (VALUES (1)) AS t(a))

statement error unsupported comparison operator: <tuple> IN <tuple{tuple{int AS a, int AS b}}>
SELECT () IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

statement error unsupported comparison operator: <tuple{string, unknown}> IN <tuple{tuple{int AS a, int AS b}}>
SELECT ('string', NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

statement error unsupported comparison operator: <tuple{int, string, unknown}> IN <tuple{tuple{int AS a, int AS b}}>
SELECT (2, 'string', NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

query B
SELECT (2, NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL, 2) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL, NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT NULL NOT IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

statement error unsupported comparison operator: <unknown> IN <tuple{tuple{int AS a, int AS b}}>
SELECT NULL NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

statement error unsupported comparison operator: <tuple> IN <tuple{int}>
SELECT () NOT IN (SELECT * FROM (VALUES (1)) AS t(a))

statement error unsupported comparison operator: <tuple> IN <tuple{tuple{int AS a, int AS b}}>
SELECT () NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

statement error unsupported comparison operator: <tuple{string, unknown}> IN <tuple{tuple{int AS a, int AS b}}>
SELECT ('string', NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

statement error unsupported comparison operator: <tuple{int, string, unknown}> IN <tuple{tuple{int AS a, int AS b}}>
SELECT (2, 'string', NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))

query B
SELECT (1, NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (2, NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL, 2) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL, NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

# Tests with an empty IN tuple.
query B
SELECT NULL IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
false

query B
SELECT (1, NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL, NULL) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT NULL NOT IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
true

query B
SELECT (1, NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL, NULL) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

statement ok
CREATE TABLE a (x INT, y INT)

statement ok
INSERT INTO a VALUES (1, 10), (2, 20), (3, 30)

query II rowsort
SELECT * FROM a WHERE x > 1
----
2  20
3  30

query II rowsort
SELECT * FROM a WHERE y > 1
----
1  10
2  20
3  30

query II
SELECT * FROM a WHERE x > 1 AND x < 3
----
2  20

query II
SELECT * FROM a WHERE x > 1 AND y < 30
----
2  20

query I rowsort
SELECT x + 1 FROM a
----
2
3
4

query IIIII rowsort
SELECT x, x + 1, y, y + 1, x + y FROM a
----
1  2  10  11  11
2  3  20  21  22
3  4  30  31  33

query I rowsort
SELECT u + v FROM (SELECT x + 3, y + 10 FROM a) AS foo(u, v)
----
24
35
46

query IIII rowsort
SELECT x, x, y, x FROM a
----
1  1  10  1
2  2  20  2
3  3  30  3

query II rowsort
SELECT x + 1, x + y FROM a WHERE x + y > 20
----
3  22
4  33

# ------------------------------------------------------------------------------
# Test with a hidden column.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE b (x INT, y INT);
INSERT INTO b VALUES (1, 10), (2, 20), (3, 30)

query II rowsort
SELECT * FROM b
----
1  10
2  20
3  30

query I rowsort
SELECT x FROM b WHERE rowid > 0
----
1
2
3

# ------------------------------------------------------------------------------
# String inequality filter.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE c (n INT, str STRING, INDEX str(str DESC));
INSERT INTO c SELECT i, to_english(i) FROM generate_series(1, 10) AS g(i)

query IT rowsort
SELECT * FROM c WHERE str >= 'moo'
----
1   one
2   two
3   three
6   six
7   seven
9   nine
10  one-zero

# ------------------------------------------------------------------------------
# "*" must expand to zero columns if there are zero columns to select.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE nocols(x INT); ALTER TABLE nocols DROP COLUMN x

query I
SELECT 1, * FROM nocols
----

# ------------------------------------------------------------------------------
# Wide tables can tickle edge cases.
# ------------------------------------------------------------------------------

statement ok
CREATE TABLE wide (id INT4 NOT NULL, a INT4, b VARCHAR(255), c INT4, d VARCHAR(255), e VARCHAR(255), f INT4, g VARCHAR(255), h VARCHAR(255), i VARCHAR(255), j VARCHAR(255), k INT4,
                   l FLOAT4, m FLOAT8, n INT2, PRIMARY KEY (id))

statement ok
INSERT INTO wide(id, n) VALUES(0, 10)

query IITITTITTTTIRRI
SELECT * FROM wide
----
0  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  10

# Regression test for #44203 (filter that is not folded inside the optimizer,
# but is statically evaluated to true when building the filterNode).
statement ok
CREATE TABLE t44203(c0 BOOL)

statement ok
INSERT INTO t44203(c0) VALUES (false)

statement ok
CREATE VIEW v44203(c0) AS SELECT c0 FROM t44203 WHERE t44203.c0 OFFSET NULL

SELECT * FROM v44203 WHERE current_user() != ''
----

# Regression test for #44132 - generated column causes incorrect scan.
statement ok
CREATE TABLE t44132(c0 BOOL UNIQUE, c1 INT AS (NULL) STORED)

statement ok
INSERT INTO t44132 (c0) VALUES (true)

query BI
SELECT * FROM t44132 WHERE c0
----
true NULL

# Tests for `disallow_full_table_scans`
statement ok
CREATE TABLE t_disallow_scans(a INT);

statement ok
INSERT INTO t_disallow_scans VALUES (1), (2), (3)

statement ok
SELECT * FROM t_disallow_scans

statement ok
SET disallow_full_table_scans = true

statement error pq: query `SELECT \* FROM t_disallow_scans` contains a full table/index scan which is explicitly disallowed
SELECT * FROM t_disallow_scans

# Internal statements should still be allowed with this setting.
statement ok
SELECT * FROM pg_class

statement ok
SELECT * FROM crdb_internal.jobs

# Cleanup
statement ok
SET disallow_full_table_scans = false

# Regression test for #58104.
statement ok
SELECT * FROM pg_catalog.pg_attrdef WHERE (adnum = 1 AND adrelid = 1) OR (adbin = 'foo' AND adrelid = 2)